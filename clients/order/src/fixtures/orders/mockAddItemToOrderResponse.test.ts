import { Order } from '@bb/common/types/tmpTypes/entityTypes';
import { mockAddItemToOrderResponse } from '@bb/common/fixtures/orders/mockAddItemToOrderResponse';
import { mockOrder } from '@bb/common/fixtures/orders/mockOrder/mockOrder';
import { v4 as uuidv4 } from 'uuid';

describe('Given an Order with no items', () => {
  let order: Order, modifiedProductVariationId: string;
  beforeEach(() => {
    order = mockOrder().value();
    modifiedProductVariationId = uuidv4();
  });
  describe('when mockAddItemToOrderResponse is called with Order and Modified Product Variation', () => {
    it('returns an Order with the provided Modified Product Variation', () => {
      const res = mockAddItemToOrderResponse({
        order,
        modifiedProductVariationId,
      });
      expect(res).toEqual({
        data: {
          order: {
            ...order,
            items: [{ ...res.data.item }], // this object is tested below
            status: ['Configuration'],
            completeConditions: [],
            incompleteConditions: [
              'ModificationsAreValid',
              'ComponentsAreAvailable',
              'ProductVariationIsProducible',
            ],
            validConditions: [],
            invalidConditions: [
              'ModificationsAreValid',
              'ComponentsAreAvailable',
              'ProductVariationIsProducible',
            ],
          },
          item: {
            id: res.data.item.id, // generated by the function
            modifiedProductVariation: {
              id: modifiedProductVariationId,
              modifications: [],
              productVariation: {
                id: res.data.item.modifiedProductVariation.productVariation.id,
                name: 'product-variation-1',
              },
            },
            status: 'Configuration',
            completeConditions: [],
            incompleteConditions: [
              'ModificationsAreValid',
              'ComponentsAreAvailable',
              'ProductVariationIsProducible',
            ],
            validConditions: [],
            invalidConditions: [
              'ModificationsAreValid',
              'ComponentsAreAvailable',
              'ProductVariationIsProducible',
            ],
          },
        },
      });
    });
  });
});

describe('Given an Order with an item in default validation', () => {
  let order: Order, modifiedProductVariationId: string;
  beforeEach(() => {
    order = mockOrder()
      .addItem({
        modifiedProductVariation: {
          id: uuidv4(),
          productVariation: {
            id: uuidv4(),
            name: `product-variation-1`,
          },
        },
      })
      .value();
    modifiedProductVariationId = uuidv4();
  });
  describe('when mockAddItemToOrderResponse is called with Order and Modified Product Variation', () => {
    it('returns an Order which includes the provided Modified Product Variation', () => {
      const res = mockAddItemToOrderResponse({
        order,
        modifiedProductVariationId,
      });
      expect(res).toEqual({
        data: {
          order: {
            ...order,
            items: [...order.items, { ...res.data.item }], // this object is tested below
            status: ['Configuration'],
            completeConditions: [],
            incompleteConditions: [
              'ModificationsAreValid',
              'ComponentsAreAvailable',
              'ProductVariationIsProducible',
            ],
            validConditions: [],
            invalidConditions: [
              'ModificationsAreValid',
              'ComponentsAreAvailable',
              'ProductVariationIsProducible',
            ],
          },
          item: {
            id: res.data.item.id, // generated by the function
            modifiedProductVariation: {
              id: modifiedProductVariationId,
              modifications: [],
              productVariation: {
                id: res.data.item.modifiedProductVariation.productVariation.id,
                name: 'product-variation-1',
              },
            },
            status: 'Configuration',
            completeConditions: [],
            incompleteConditions: [
              'ModificationsAreValid',
              'ComponentsAreAvailable',
              'ProductVariationIsProducible',
            ],
            validConditions: [],
            invalidConditions: [
              'ModificationsAreValid',
              'ComponentsAreAvailable',
              'ProductVariationIsProducible',
            ],
          },
        },
      });
    });
  });
});

describe('Given an Order with an item in non-default validation', () => {
  let order: Order, modifiedProductVariationId: string;
  beforeEach(() => {
    // @TODO do this with mock validation call instead
    order = {
      ...mockOrder()
        .addItem({
          modifiedProductVariation: {
            id: uuidv4(),
            productVariation: {
              id: uuidv4(),
              name: `product-variation-1`,
            },
          },
        })
        .value(),
      completeConditions: [
        'ModificationsAreValid',
        'ComponentsAreAvailable',
        'ProductVariationIsProducible',
      ],
      validConditions: [
        'ModificationsAreValid',
        'ComponentsAreAvailable',
        'ProductVariationIsProducible',
      ],
    };
    modifiedProductVariationId = uuidv4();
  });
  describe('when mockAddItemToOrderResponse is called with Order and Modified Product Variation', () => {
    it('returns an Order which includes the provided Modified Product Variation and has reset validation', () => {
      const res = mockAddItemToOrderResponse({
        order,
        modifiedProductVariationId,
      });
      expect(res).toEqual({
        data: {
          order: {
            ...order,
            items: [...order.items, { ...res.data.item }], // this object is tested below
            status: ['Configuration'],
            completeConditions: [],
            incompleteConditions: [
              'ModificationsAreValid',
              'ComponentsAreAvailable',
              'ProductVariationIsProducible',
            ],
            validConditions: [],
            invalidConditions: [
              'ModificationsAreValid',
              'ComponentsAreAvailable',
              'ProductVariationIsProducible',
            ],
          },
          item: {
            id: res.data.item.id, // generated by the function
            modifiedProductVariation: {
              id: modifiedProductVariationId,
              modifications: [],
              productVariation: {
                id: res.data.item.modifiedProductVariation.productVariation.id,
                name: 'product-variation-1',
              },
            },
            status: 'Configuration',
            completeConditions: [],
            incompleteConditions: [
              'ModificationsAreValid',
              'ComponentsAreAvailable',
              'ProductVariationIsProducible',
            ],
            validConditions: [],
            invalidConditions: [
              'ModificationsAreValid',
              'ComponentsAreAvailable',
              'ProductVariationIsProducible',
            ],
          },
        },
      });
    });
  });
});
