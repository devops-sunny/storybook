import { ChainableMockProducer } from '@bb/common/types/tmpTypes/chainableTypes';
import { Producer } from '@bb/common/types/tmpTypes/entityTypes';
import { mockProducer } from '@bb/common/fixtures/producers/mockProducer';

describe('Given mockProducer helpers', () => {
  beforeEach(() => {
    jest.useFakeTimers();
  });
  afterEach(() => {
    jest.useRealTimers();
  });
  describe('when mockProducer is called', () => {
    it('returns a unique producer', () => {
      const producer: Producer = mockProducer().value();
      expect(producer).toEqual({
        id: producer.id, // generated by mock function
        heartbeatAt: producer.heartbeatAt, // generated by mock function
      });
    });
  });
  describe('when mockProducer().updateHeartbeat() is chained', () => {
    it('returns a Producer with a newer heartbeatAt', () => {
      const baseProducer: ChainableMockProducer = mockProducer();
      // we need to store a ref to the current state for comparison in expect (baseProducer will be mutated)
      const baseProducerRef: Producer = baseProducer.value();
      jest.advanceTimersByTime(1);
      const producer: Producer = baseProducer.updateHeartbeat().value();
      expect(producer.heartbeatAt.getTime()).toBeGreaterThan(
        baseProducerRef.heartbeatAt.getTime(),
      );
    });
  });
  describe('when updateHeartbeat() is chained on an existing mockProducer(...)', () => {
    it('returns a Producer with a newer heartbeatAt', () => {
      const baseProducer: Producer = mockProducer().value();
      jest.advanceTimersByTime(1);
      const producer: Producer = mockProducer({
        producer: baseProducer,
      })
        .updateHeartbeat()
        .value();
      expect(producer.id).toBe(baseProducer.id);
      expect(producer.heartbeatAt.getTime()).toBeGreaterThan(
        baseProducer.heartbeatAt.getTime(),
      );
    });
  });
});
